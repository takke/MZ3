.はじめに

JRegexとその他正規表現について書き殴っています
こちらは内部解説、関数説明が主です
アルゴリズム関連、考察等は doc2 に記しています

.JRegex内部解説

  * 概要のみ解説します
  * アルゴリズムは稚拙ながら doc2 にて解説しています
  * 関数の引数の解説、詳細はソースコードから参照してください
  * DFAの解説は本人も理解していないのでご容赦ください (._.;;


JRegexは大きく分けて構文解析と実行の2つのフェーズで正規表現を扱います
  (DFAを扱う場合さらに構文解析に続いて変換動作が入ります)

構文解析のフェーズでは文字列である正規表現を実行解釈可能な
ノードと呼ぶ単位に変換します
ノードはリンクリスト(チェーン構造)を用いた簡易なモデルを用いており
ノード全体が木構造のような形をとります
  (この後、DFAを扱う場合必要要素のみを列挙したテーブルを作ります)
jreg_parse_union/jreg_parse 関数でこれを行います

実行フェーズでは構文解析フェーズで作ったリンクリストと
与えられた文字列との照合を行います
jreg_scan_node 関数がこれを行います

..関数マクロ概要

_rstr2ch       検索対象の文字を取得します
_rstr*         その他 _rstr で始まるマクロは検索対象の文字を評価するものです

対象文字列操作は全て _rstr* 系のマクロを利用することで SJIS/UNICODE対応になります
  (単なる文字列に対しては WinSDKにある _t* 系のマクロや独自マクロを用います)


_type_set      ノードにタイプ(属性)を設定します、ノードは単一の属性を持ちます
_type_get      ノードのタイプを取得します
_type_istype   ノードが指定のタイプであるかどうか判断します
_type_optadd   ノードにオプション値を設定します、オプションは複数持てます
_type_optrem   ノードからオプション値を削除します
_type_isopt    ノードにオプション値が設定されているか判断します


_bit*          ビット操作を行います、DFAでしか用いないため説明は省略
_dfa*          DFAテーブルの操作を行います

..構造体解説

JNODE      ノードを表す構造体
  type     タイプとオプション値
  Data     タイプに対応するノードのデータ (文字列、繰り返し情報など)
  next     次のノード
  selnum   ノード番号 (DFAでのみ利用)

ノードはそのタイプから string/charノード (文字列)、metaノード (メタ文字)、
closureノード (繰り返し * + ? など)、unionノード (括弧)、
cclassノード (文字クラス)、emptyノード (未設定)と呼びます

closureノードとunionノードは Dataに別個ノードを持っています


JREGPARENT 親状態を表す構造体
  node     親のノード
  Parent   親の親の状態
  start    親状態開始位置

JREGPARENT は正規表現の実行フェーズにかかせないものです
正規表現は `親の次' や `親の親' などを実行時に必要とするためです

これ以外については各項にて解説しています (してないのもあります ^-^;)

..構文解析関数

構文解析に用いる関数の概要です

jreg_comp
  正規表現のコンパイルを行います (* 利用方法は API.txt 参照)
  perl互換(なるべく)の文法を解釈します

jreg_exec
  正規表現のマッチングを行います (* 利用方法は API.txt 参照)
  与えられた文字列とのマッチングを行い
  マッチしたかどうかを返します
  マッチ位置はjreg構造体から参照します

jreg_replace
  置き換え後文字列を作成します (* 利用方法は API.txt 参照)
  与えられた文字列とのマッチングを行い
  マッチしていれば与えられたバッファに文字を構築していきます

jreg_free
  正規表現情報を解放します (* 利用方法は API.txt 参照)
  使用後は呼び出し側で呼び出して下さい

jreg_free_node
  正規表現ノードを再帰的に解放します
  closureノードとunionノードはその内部の子まで解放します

jreg_new_node
  ノードを作成します
  直前のノードを受け取りそのノードに接続します
  * ただし直前のノードがemptyノードであればそれを再利用します
  * unionノードが最初の子ノードとして明示的にemptyノードを作成するためです

  closureノード作成の際には直前のノードを自分の子として取り込みます
  * 直前がemptyノードの場合には失敗します

jreg_prev_node
  直前のノードを取得します
  closureノードが直前のノードを取り込むために利用します
  * char, cclass, meta, unionの各ノードはそのまま返されます
  * stringノードは最後の一文字を切り取りcharノードとして返されます
  直前にclosureノードがある場合失敗します

jreg_get_cnt
  ノードがマッチした場合の文字数を返します
  * 戻り読みを実装するためにマッチした場合の文字数が必要になります

  たとえば m/(?<=a|bc)/ はコンパイルエラーです
  unionノードの a の部分と bc の部分の文字数が違い
  何文字戻ればいいのか明確にならないためです
  この関数はその文字数を数え整合性を確認します

jreg_parse_union
  unionノードに関連する正規表現を構文解析します
  拡張正規表現の解釈、(x1|y1) と言った | で分割されたものを解釈します
  * この関数は括弧以外の解析を jreg_parse 関数に委ねます

jreg_parse
  正規表現を解析します
  * この関数は終端文字を引数に取ります ( `(' に対する `)' )

  '\0' の場合正規表現の解析を終了させます
  * 終端文字が \0 でなければエラーになります ( 対応していない対括弧のため )

  '|' 正規表現のパースを終了させ、必ず正常終了します
  * 処理は上流の jreg_parse_union 関数に戻り新たに解釈を再開します

  '(' ではunionノードを作成します
  * この時作られたunionノードには JREG_HEAD オプションが付けられ
  *  拡張正規表現の対象になります

  '[' ではclassノードを作成します
  * 先頭に ^ がついている場合は JREG_NOT オプションを付加します
  * jreg_cc 関数によって1文字づつ読み進め ] がくるまでループします

  '{' ではclosureノードを作成します
  続く数値の列を解釈し {n} {n,} {n,m} をループ回数に変換します
  * JREG_NOVLEN(戻り読みの内部) フラグがついている場合は
  *  {n,} {n,m} の形式をエラーにします

  '*' closureノードを作成します
  * JREG_NOVLEN(戻り読みの内部) フラグがついている場合はエラーになります

  '+' closureノードを作成します
  * JREG_NOVLEN(戻り読みの内部) フラグがついている場合はエラーになります

  '?' closureノードを作成します
  * 直前ノードがclosureノードの場合 JREG_NONGREEDY フラグを付加します
  * JREG_NOVLEN(戻り読みの内部) フラグがついている場合はエラーになります
  *  ただし a{n}? の様な用法は意味はないがエラーではないので注意

  '.' '\' '^' '$' などはmetaノードを作成します
  metaノードはその種類によってさらに分類されます
  メタ文字のタイプを参照して下さい
  そのためオプション値の使い方が各個違います
  * メタ文字の解釈は jreg_meta 関数に委ねられます

  その他はstringノードを作成します
  * 直前のノードがstringノードであればそれを拡張します

...メタ文字

メタ文字を解釈する関数の分類として以下のものがあります

jreg_meta
  一般的なメタ文字を扱います (文字、文字表現、アンカー、後方参照)
  文字クラス式内部かどうかを引数として受け取り動作を変えます
  文字クラス内では . はただの文字になり、アンカーは無視されます
  全くメタ文字でないただの文字も扱うことができます (jreg_metaxとの絡みのためです)

jreg_meta_ctrl
  jreg_meta から \C-x \cx \M-x を解釈するために呼ばれます
  別に関数化されているのは \C-\C-x という書き方が存在するためです

jreg_cc
  文字クラス式内部の文字を扱います (内部的にメタ文字としています)
  範囲文字、名前付き文字クラスを扱います
  範囲文字は引数で解釈するかどうか動作を変えます

jreg_metax
  置き換え文字列のメタ文字を扱います ($nn $& $` $' $+)
  それ以外の文字は jreg_meta に任せます

jreg_ismeta
  与えられた文字とメタ文字(\w \d \s . などのみ)が一致するか調べます

....メタ文字のタイプ

メタ文字は JREGCC_* のようなタイプ名で分類されます

JREGCC_META     一般的であろう \w \s \d . から
JREGCC_CHAR     文字コードを直接記述できる \xnn \onn \C-x
JREGCC_BACKREF  後方参照の \nn
JREGCC_CTRL     アンカーの \b \z ^ $
JREGCC_PROC     文字クラス式内で用いる [:alnum:]
JREGCC_RANGE    文字クラス式内で範囲を表す -
JREGCC_MATCH*   置き換え文字列として用いる $nn $& $` $' $+
JREGCC_ERROR    エラー
  * (あくまでプログラムの内部的な分類でメタ文字として扱われているだけです)

..実行関数

実行に用いる関数の概要です

jreg_scan_node
  実行のメインになります

ノードのタイプごとに動作が異なりますが基本動作は以下のとおりです

1. ノードがあればそのノードと対象文字列を比較
   一致すれば次のノードに移る、不一致なら即座に関数を抜ける
2. 1を次のノードがなくなるまで繰り返す
3. ノードがなくなれば `親のノードの次のノード' へ移る
   ただし、親のノードがclosureノードなら次へうつる前にもう一度ループをやり直す

...1. 比較手順

上記の 1の部分がノードのタイプごとに変わる部分です
比較対象のの文字は _rstr*系の関数を使って取得します
マッチしたとき文字数をカウントアップしていきます
  * 文字数をカウントアップする際 マッチした文字数+1 を返します
  * 0幅マッチに対応するためで 1 となります
  * 0は非マッチでエラーになります (非マッチが分かった時点で大抵は関数を抜けます)

  emptyノードは常にマッチとなります
  * emptyノードはunionノードを作成する際内部的に生成される仮想のノードです
  * 本来なら実行時には取り除かれていなければならないんですが ^^;

  stringノードは文字と対象を比較するだけです
  charノードも文字数が1なだけのstringノードですので処理は共通です

  metaノードはその種類により比較処理が振り分けられます
  メタ文字のタイプの項で列記したような種類があります
  * JREGCC_METAの処理は jreg_ismeta関数に委ねています (DFAでも使うためです)
  * JREGCC_CTRLの処理も同様に jreg_ismeta_anc関数に委ねています

  classノードは実行時の処理を jreg_iscc関数に委ねています (DFAでも使うためです)

  closureノードはちょっと複雑です
  ここでは基本的に次のノードには移りません
  closureノードは自分の子としてループするノードを別に持っているので
  現在のclosureノードを親にし、子を使って jreg_scan_node関数を実行します
  * 最短一致で最低繰り返し数0なら先に次のノードを確認します
  * 最長一致で最低繰り返し数0で、かつ子のノードが全て失敗すれば次のノードを試します
  * 限定一致は子の呼び出しを限界まで行った際のループ回数が得られます
  * 処理が子に渡った場合、子のループが完了すると
  *  前述 3の処理となり子が `親の次' を呼びます (最長一致のバックトラック)

  unionノードはかなり複雑です
  処理の性質上、前述 3の処理と絡んだ箇所がいくつかあります
  unionノードは自分の子となるノードを別に2つ持っているので
  現在のunionノードを親にし、子を使って jreg_scan_node関数を実行します
  * 戻り読みの際は比較対象位置を事前に計算しておいた文字数分戻します
  * 戻り読み否定、先読み否定がマッチすると前述 3の処理で返ってきます
  * 先読みではその先のマッチ幅を特別な位置に格納し返されます
  * 戻り読みでは重複してマッチしてしまった部分を減算します

...2. 繰り返し処理

上記の 1の処理を終わりが来るまで繰り返します

...3. 親処理

上記の 2の処理が終わると親を調べます
親になりうるのは closureノードと unionノードです
役目は親の次のノードを調べることです (両ノードは 1の処理で次のノードを調べません)

  親がclosureノードの場合はまずループ回数を計算します
  ループ回数が上限に達すれば次のノードを調べます
  ループに失敗してもループ回数の下限を超えていれば次のノードを調べます
  * 最短一致の場合ループ回数の下限を超えれば先に次のノードを調べます
  * 限定一致の場合常にループを調べます

  親がunionノードの場合はまず拡張正規表現の場合を考え振り分けます
  否定 ( ?! ?<! ) が付いていればマッチしてはいけないので逆に失敗にします
  長さ無視 ( ?= ?<= ) が付いている場合次のノードを調べそのマッチ幅のみを返します
  後方参照が付いている場合マッチ幅と位置を保存して次のノードを調べます
  特に何もなければ ( ?: ) 次のノードを調べます

親のノードがなければ、つまり最後までたどれれば成功としてマッチ幅を返します
